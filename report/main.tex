\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2.5cm}

\title{\textbf{Acting Shooting Star : Notre version de Crossy Road basé sur le modèle des acteurs}}
\author{Enzo Picarel, Raphaël Bely, Arno Donias, Thibault Abeille\\ 
Encadrants : Vincent Alba, David Renault \\ ENSEIRB-MATMECA – 2025}
\date{\today}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolor}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolor},
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{orange},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}

Dans le cadre de notre projet de programmation en JavaScript, nous avons fait le choix de créer notre propre version du jeu Crossy Road. C'est un jeu mobile populaire auquel on a joué durant notre enfance. Ce fut un choix naturel. En effet, son aspect ludique et familier permet une certaine simplicité d'implémentation qui permet de satisfaire les exigences pour un premier projet dans ce langage. Nous verrons par la suite, que, grâce à notre imagination, nous n'avons pas été restreints par la simplicité du jeu.\\

Le projet est axé principalement sur la conception d'un moteur de jeu basé sur un modèle fonctionnant par interaction des objets définis en tant qu'"acteur". Ces acteurs (qui vont du poulet à la bûche en passant par les voitures) sont indépendants les uns des autres. Chaque acteur devait être capable de recevoir des informations sous forme de messages, puis de traiter ces messages et enfin de réagir en fonction. Pendant l'implémentation, nous avons fait particulièrement attention à avoir un code avec une pureté fonctionnelle maximale, en évitant les effets de bord et en respectant les principes de la programmation fonctionnelle autant que possible.\\

Le projet était cadré par des contraintes définies en relation avec le cours de programmation fonctionnelle et d'utilisation de \textit{Typescript}. Les exigences étaient les suivantes :
\begin{itemize}
	\item affichage dans le terminal même à l'aide de \textit{terminal-kit}
	\item code validé grâce à l'utilisation d'\textit{ESLint}
	\item tests unitaires avec \textit{Jest}
	\item développement collaboratif avec un dépôt git
	\item code structuré selon les consignes 
\end{itemize}

Durant ce rapport nous aborderons plusieurs thèmes principaux du développement comme la conception des acteurs, l'architecture du jeu, son implémentation, ainsi qu'un retour sur expérience contenant les difficultés rencontrées et nos apprentissages durant le projet.

\section{Modèle des acteurs et principes de conception}

L'architecture complète du jeu est basée entièrement sur un modèle comportant des acteurs. Ces acteurs font office de \textbf{structures abstraites de données}. En effet, leur implémentation est cachée derrière le type \textbf{Actor} défini dans le fichier \textit{actor.ts} et généré à l'aide de la fonction \textit{make\_actor}. Les acteurs doivent posséder :
\begin{itemize}
  \item une \textbf{mailbox} afin de recevoir des messages ou instructions ;
  \item une fonction centrale \textit{update} qui lit les messages et renvoie une nouvelle version de l'acteur après avoir effectué les changements propres aux instructions lues ;
  \item plusieurs fonctions génériques comme \textit{move, collide ou tick} communes à tous les acteurs de notre jeu ;
\end{itemize}

Les messages échangés par les acteurs sont typés par une structure composé d'un champ \texttt{type} (chaîne de caractères) et un champ \texttt{params} (tableau d'arguments). Ces messages permettent la transmission des différentes actions à effectuer, faisant réagir les acteurs de manière \textbf{autonome} et \textbf{indépendante} durant le déroulement du jeu.\\

Le modèle repose sur la mise à jour successive et répétée des acteurs: quand l'un d'eux reçoit un \textbf{"tick"}, il ne modifie pas vraiment sont propre état, à la place, il crée une nouvelle version de lui-même en fonction des messages/instructions reçues.\\

Le fonctionnement du jeu est dirigé par un \textbf{runtime} comportant plusieurs boucles d'exécution indépendantes (\texttt{setinterval}) en fonction des acteurs, telles que \texttt{intervalProj, tickInterval ou carInterval}. Ce sont elles qui déclenchent des tick à fréquences différentes selon l'acteur impacté. \\

Le monde contenant tout les acteurs est également sauvegarder régulièrement. Les versions du mondes sont enregistrées dans une file qui permet alors le \textbf{retour en arrière}. Le monde actuel correspond au dernièr élément de la file, ainsi afin de revenir en arrière, il faut replacer cet élément par un élément placé précédemment dans la file, ce qui permet de revenir dans un état antérieur du jeu. \\

Bien que ce modèle ait offert une approche intuitive et modulaire pour gérer les interactions entre les entités du jeu, il a également introduit une certaine \textbf{rigidité}. La recréation fréquente d’acteurs, imposée par la pureté fonctionnelle, a parfois généré des bugs graphiques et une complexité de gestion accrue. Néanmoins, cette architecture s’est révélée pertinente pour développer des comportements réactifs, évitant la prolifération de structures conditionnelles complexes. \\

\section{Architecture du jeu}

L'architecture du jeu repose sur la modélisation de toutes les entités visibles sous forme d'acteurs. On distingue plusieurs types d'acteurs :
\begin{itemize}
  \item \textbf{Chicken} : l’acteur principal contrôlé par le joueur ;
  \item \textbf{Tree}, \textbf{Water\_L}, \textbf{Water\_R}, \textbf{Log\_L}, \textbf{Log\_R}, \textbf{Car\_L}, \textbf{Car\_R} : éléments dynamiques ou statiques constituant les obstacles ;
  \item \textbf{Projectile} : acteur créé par le joueur pour détruire certains obstacles ;
  \item \textbf{Empty} : utilisé pour représenter une cellule vide dans le monde.
\end{itemize}

Tous les acteurs partagent un ensemble de fonctions communes, comme \texttt{tick}, \texttt{move} ou \texttt{update}. Une fonction \texttt{collide} était initialement prévue mais n'est finalement pas utilisée. La détection des collisions se fait par simple comparaison des positions avec l’acteur principal. Si un acteur occupe la même case que le joueur, la partie est terminée.

L’identité d’un acteur est déterminée à sa création par la fonction \texttt{make\_actor}, à partir d’un \texttt{nom} et d’une \texttt{position}. Ces éléments sont suffisants pour distinguer les comportements spécifiques.

Le monde est représenté comme une structure contenant un tableau de lignes (\texttt{Line[]}), chacune de ces lignes étant composée d’acteurs. La progression du jeu se fait par le défilement automatique de ces lignes, simulant l’avancement du joueur. Ce système permet de maintenir une tension continue : si le joueur avance rapidement, le monde suit son rythme ; s’il reste en bas de l’écran, le défilement automatique reprend.

Les lignes sont générées dynamiquement via la fonction \texttt{tick\_line}, à chaque avancée du monde. Elles sont construites à partir de motifs d’obstacles (2 à 4 cases consécutives), ce qui permet de représenter visuellement des camions, rangées d’arbres ou bûches flottantes. La probabilité d’apparition des obstacles augmente progressivement, suivant une logique de difficulté croissante. Les motifs sont choisis et combinés aléatoirement, ce qui rend peu probable la répétition exacte de deux lignes.

Aucun système ne garantit qu’un chemin praticable existe toujours, mais la rareté des impasses et la possibilité pour le joueur de tirer des projectiles destructeurs offrent un équilibre entre hasard et jouabilité. Les projectiles, comme tous les autres éléments mobiles, sont des acteurs à part entière. Le déplacement dans le monde se fait par recréation successive d’acteurs dans de nouvelles positions, selon une logique purement fonctionnelle.

Enfin, toutes les collisions avec des obstacles sont létales : la gestion des règles est donc simple mais rigoureuse, renforçant l’aspect arcade et punitif du jeu.

\section{Implémentation technique}

Le projet est organisé selon une structure claire et modulaire. Le répertoire principal contient les fichiers de configuration nécessaires pour l’utilisation de \texttt{ESLint}, \texttt{Jest}, ainsi qu’un \texttt{Makefile} destiné à automatiser les différentes tâches de compilation, d’exécution et de tests.

\subsection*{Organisation des fichiers}

\begin{itemize}
  \item \textbf{src/} : contient les fichiers source principaux :
  \begin{itemize}
    \item \texttt{actor.ts} : implémente les fonctions de création et de gestion des acteurs ;
    \item \texttt{world.ts} : contient la logique de simulation du monde, les ticks, le moteur du jeu et l’affichage terminal.
  \end{itemize}
  \item \textbf{test/} : contient les tests unitaires, notamment \texttt{actor.test.ts} qui vérifie le bon fonctionnement des fonctions définies dans \texttt{actor.ts}.
  \item \textbf{dist/} : contient les fichiers JavaScript générés automatiquement à la compilation.
\end{itemize}

\subsection*{Technologies et outils utilisés}

Le développement repose sur plusieurs outils modernes :
\begin{itemize}
  \item \texttt{TypeScript} pour garantir un typage statique des données ;
  \item \texttt{ESLint} pour assurer une qualité de code homogène (indentation, style, bonne utilisation des structures) ;
  \item \texttt{Jest} pour l’écriture et l’exécution des tests unitaires ;
  \item \texttt{terminal-kit} pour l’affichage dynamique dans le terminal.
\end{itemize}

La configuration TypeScript (\texttt{tsconfig.json}) et le \texttt{Makefile} étaient fournis dans le sujet. Le Makefile propose notamment une commande \texttt{make run} qui compile le projet avec \texttt{tsc} puis exécute le jeu via Node.js :

\begin{lstlisting}[language=bash]
npx tsc
node dist/src/world.js
\end{lstlisting}

Le fichier principal d’exécution est \texttt{world.ts}, qui gère l’ensemble de la boucle de jeu.

Le jeu est entièrement jouable depuis un terminal, sans interface graphique additionnelle. L’affichage s’adapte dynamiquement à la taille de l’écran du terminal, ce qui permet une bonne ergonomie malgré l’usage de caractères ASCII.

\subsection*{Éléments clés du code}

Trois éléments de l’implémentation méritent une attention particulière :
\begin{itemize}
  \item \textbf{Le système de tick} : chaque type d’acteur est mis à jour à une fréquence spécifique via des fonctions \texttt{setInterval}. Cela permet de différencier la cadence de déplacement des voitures, bûches, projectiles, etc.
  \item \textbf{La génération d’acteurs} : la fonction \texttt{make\_actor} crée des entités selon leur type, leur position et leur comportement à partir de modèles réutilisables.
  \item \textbf{La génération de lignes} : des motifs prédéfinis (pattern) permettent de générer dynamiquement des obstacles selon une probabilité qui augmente avec la progression du joueur. Cela assure un équilibre entre imprévisibilité et jouabilité.
\end{itemize}

\section{Affichage et interactions}
\begin{itemize}
  \item Affichage ASCII dans le terminal
  \item Contraintes liées à \texttt{terminal-kit}
  \item Possibilités d'interactions (touches clavier, etc.)
\end{itemize}

\section{Difficultés rencontrées et solutions apportées}
\begin{itemize}
  \item Collisions sans effets de bord
  \item Identification des acteurs et passage de tick
  \item Débogage et visualisation du comportement
\end{itemize}

\section{Évaluation}
\begin{itemize}
  \item Fonctionnalité et stabilité
  \item Performances en terminal
  \item Extensibilité du moteur de jeu
\end{itemize}

\section{Conclusion et perspectives}
Résumé des apports du projet, limites actuelles, et pistes d'amélioration (graphismes, IA, multijoueur, temps réel).

\section*{Références}
\begin{itemize}
  \item Documentation de \texttt{terminal-kit}: \url{https://github.com/cronvel/terminal-kit}
  \item Tutoriel sur le modèle des acteurs
  \item Documentation ESLint / Jest / TypeScript
\end{itemize}

\end{document}
