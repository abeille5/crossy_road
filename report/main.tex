\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2.5cm}

\title{\textbf{Acting Shooting Star : Notre version de Crossy Road basé sur le modèle acteurs}}
\author{Enzo Picarel, Raphaël Bely, Arno Donias, Thibault Abeille\\ 
Encadrants : Vincent Alba, David Renault \\ ENSEIRB-MATMECA – 2025}
\date{\today}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolor}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolor},
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{orange},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}

Dans le cadre de notre projet de programmation en JavaScript, nous avons fait le choix de créer notre propre version du jeu Crossy Road. C'est un jeu mobile populaire auquel nous avons joué durant notre enfance. Ce fut un choix naturel. En effet, son aspect ludique et familier permet une certaine simplicité d'implémentation qui permet de satisfaire les exigences pour un premier projet dans ce langage. Nous verrons par la suite, que, grâce à notre imagination, nous n'avons pas été restreints par la simplicité du jeu.\\

Le projet est axé principalement sur la conception d'un moteur de jeu basé sur un modèle fonctionnant par interaction des objets définis en tant qu'"acteur". Ces acteurs (qui vont du poulet à la bûche en passant par les voitures) sont indépendants les uns des autres. Chaque acteur doit être capable de recevoir des informations sous forme de messages, puis de traiter ces messages et enfin de réagir en fonction. Pendant l'implémentation, nous avons fait particulièrement attention à avoir un code avec une pureté fonctionnelle maximale, en évitant les effets de bord et en respectant les principes de la programmation fonctionnelle autant que possible.\\

Ce projet est cadré par des contraintes définies en relation avec le cours PG104 (programmation fonctionnelle) et d'utilisation du langage \textit{Typescript}. Les exigences sont les suivantes :
\begin{itemize}
	\item affichage dans le terminal même à l'aide de \textit{terminal-kit}
	\item code validé grâce à l'utilisation d'\textit{ESLint}
	\item tests unitaires avec \textit{Jest}
	\item développement collaboratif avec un dépôt git
	\item code structuré selon les consignes (dossier: src, test, dist et fichiers de configuration: *.config.*)
\end{itemize}

Durant ce rapport nous aborderons plusieurs thèmes principaux du développement comme la conception des acteurs, l'architecture du jeu, son implémentation, ainsi qu'un retour sur expérience contenant les difficultés rencontrées et nos apprentissages durant le projet.

\section{Principe et règle du jeu}

Le temps d'une partie, devenez un \textbf{Poulet} vif et agile dans un monde infini fait de multiples danger qui peuvent vous atteindre. \\

Le but du jeu ? Avancer le plus loin posssible sans mourrir écrasé, noyé ou rattrapé par le temps. 
Vous avez à votre disposition plusieurs touche vous permettant d'évoluer dans le monde :
\begin{itemize}
  \item \texttt{UP} pour avancer plus loin et gagner en score
  \item \texttt{DOWN} pour reculer si jamais vous êtes dans une impasse
  \item \texttt{LEFT} pour aller à gauche
  \item \texttt{RIGHT} pour aller à droite
  \item \texttt{E} pour activer le super pouvoir de votre poulet et cracher des boules de feu.
\end{itemize}

Pendant votre périple, avancez à votre rythme mais évitez de prendre trop votre temps ! Faites attention à éviter voitures et camions sur les routes, ainsi qu'à ne pas tomber dans l'eau en traversant une rivière. Les arbres aussi ne sont pas amicaux, tapez-vous la tête dessus et c'en est fini de votre poulet. 

Plus vous avancez, plus les voitures sont nombreuses, moins il y a de passerelles (bûches) pour traverser une rivière et plus vous paniquerez à l'idée d'être trop lent. 

Heureusement, vous pouvez toujours vous sauver en tirant une boule de feu, permettant de détruire un obstacle qui vous barre la route. Mais attention, celles-ci sont limitées et bien qu'elles se régénèrent, une utilisation abusive mènera à votre perte. 

\section{Modèle des acteurs et principes de conception}

L'architecture complète du jeu est basée entièrement sur un modèle comportant des acteurs. Ces acteurs font office de \textbf{structures abstraites de données}. En effet, leur implémentation est cachée derrière le type \textbf{Actor} défini dans le fichier \textit{actor.ts} et généré à l'aide de la fonction \textit{make\_actor}. Les acteurs doivent posséder :
\begin{itemize}
  \item une \textbf{mailbox} afin de recevoir des messages ou instructions ;
  \item une fonction centrale \textit{update} qui lit les messages et renvoie une nouvelle version de l'acteur après avoir effectué les changements propres aux instructions lues ;
  \item plusieurs fonctions génériques comme \textit{move, collide ou tick} communes à tous les acteurs de notre jeu ;
\end{itemize}

Les messages échangés par les acteurs sont typés par une structure composé d'un champ \texttt{type} (chaîne de caractères) et un champ \texttt{params} (tableau d'arguments). Ces messages permettent la transmission des différentes actions à effectuer, faisant réagir les acteurs de manière \textbf{autonome} et \textbf{indépendante} durant le déroulement du jeu.\\

Le modèle repose sur la mise à jour successive et répétée des acteurs: quand l'un d'eux reçoit un \textbf{"tick"}, il ne modifie pas vraiment sont propre état, à la place, il crée une nouvelle version de lui-même en fonction des messages/instructions reçues.\\

Le fonctionnement du jeu est dirigé par un \textbf{runtime} comportant une boucle d'exécution (\texttt{setinterval}). Les actions répétitives des acteurs et les ticks du jeu sont déclenchés par cette boucle à des intervales réguliers, qui peuvent différés selon le type d'acteur concerné.\\

Le monde contenant tout les acteurs est également sauvegarder régulièrement. Les versions du mondes sont enregistrées dans une file qui permet alors le \textbf{retour en arrière}. Le monde actuel correspond au dernièr élément de la file, ainsi afin de revenir en arrière, il faut replacer cet élément par un élément placé précédemment dans la file, ce qui permet de revenir dans un état antérieur du jeu. \\

Bien que ce modèle ait offert une approche intuitive et modulaire pour gérer les interactions entre les entités du jeu, il a également introduit une certaine \textbf{rigidité}. La recréation fréquente d’acteurs, imposée par la pureté fonctionnelle, a parfois généré des bugs graphiques et une complexité de gestion accrue. Néanmoins, cette architecture s’est révélée pertinente pour développer des comportements réactifs, évitant la prolifération de structures conditionnelles complexes. \\

\section{Architecture du jeu}

\subsection*{Gestion des acteurs}

La description du jeu repose sur la modélisation de tout ce que l'on voit par des acteurs. On en distingue plusieurs types :
\begin{itemize}
  \item[$\bullet$] \textbf{Chicken} : l’acteur principal contrôlé par le joueur ;
  \item[$\bullet$] \textbf{Tree}, \textbf{Water\_L}, \textbf{Water\_R}, \textbf{Log\_L}, \textbf{Log\_R}, \textbf{Car\_L}, \textbf{Car\_R} : éléments dynamiques ou statiques constituant les obstacles ;
  \item[$\bullet$] \textbf{Projectile} : acteur créé par le joueur pour détruire certains obstacles ;
  \item[$\bullet$] \textbf{Empty} : utilisé pour représenter une cellule vide dans le monde.
\end{itemize}

\vspace{1em}

Ces acteurs partagent des fonctions communes car ils les utilisent tous et réagissent aux messages grâce à elles. Ces fonctions sont : 
\begin{itemize}
	\item[$\bullet$] \texttt{move} qui permet à l'acteur de modifier sa position ;
	\item[$\bullet$] \texttt{tick} qui permet de déclencher l'action de mouvement pendant le déroulement du jeu ;
	\item[$\bullet$] \texttt{collide} qui permet de réagir (dans notre cas d'arrêter la partie) en cas de collision avec un objet ennemi.
\end{itemize}

\vspace{1em}

Notre monde de jeu est quant à lui représenté par une table de lignes (\texttt{TypeLine}). Ces lignes comportent autant d'acteurs que la largeur du monde, mais aussi :
\begin{itemize}
  \item[$\bullet$] le type de ligne : une rivière, une route ou la nature ;
  \item[$\bullet$] un tableau \texttt{data} comportant les acteurs de la ligne ;
  \item[$\bullet$] un tableau \texttt{pattern} et une variable \texttt{patternIndex} que nous détaillerons par la suite.
\end{itemize}

\vspace{1em}

Le déplacement des acteurs dans le monde, régi par les fonctions \texttt{tick} et \texttt{move}, se fait par recréation successive d'acteurs dans de nouvelles positions, ce qui permet une implémentation purement fonctionnelle. Les projectiles ou boules de feu sont, comme tous les autres éléments du jeu, des acteurs à part entière.

\vspace{1em}

Pour terminer ces explications du jeu, les collisions sont létales instantanément, ce qui permet de renforcer l'aspect punitif du jeu et de maintenir le joueur concentré.

\subsection*{Gestion du jeu}

Pour conserver une gestion pure des données, les mondes dans lesquels les acteurs évoluent sont des structures de données \texttt{World} stockées dans une file.\\
La structure de donnée \texttt{World} contient certaines données utiles au déroulement du jeu :
\begin{itemize}
   \item \texttt{lines} : une file de lignes
   \item \texttt{poulet} : le personnage principale du jeu, stocké indépendamment des autres acteurs et modifiable en fonction des actions du joueur
   \item \texttt{arrayProj} : un tableau d'acteur projectile, qui peuvent être créé lorsque le joueur veut cracher une boule de feu
\end{itemize}

A chaque tick du jeu, plusieurs actions s'effectuent sur les acteurs, les lignes et les mondes. Elles se résument en 3 étapes : \\
\begin{enumerate}
\item Le terrain est décalé d'un cran vers le bas, pour faire défiler les éléments du jeu. Cela se manifeste par un défilement des lignes. Pour garantir la pureté du code, la ligne à défiler est remplacée par une ligne vierge, puis enfilée à la manière d'un convoyeur.
\item Le poulet est déplacé vers le bas également. Ne faisant pas partie des autres acteurs, son déplacement se fait indépendamment.
\item Le monde actuel est remplacé dans la file par son successeur. Ce monde est généré par la fonction \textit{make\_world} en héritant de la file de ligne, du poulet et des projectiles du monde actuel, auxquels est appliqué le défilement du terrain.
\end{enumerate}

Les données du jeu peuvent changer plus fréquemment que les ticks. La mise à jour des acteurs doit donc suivre ce rythme à côté de celui des ticks. A la différence du défilement à chaque tick, la mise à jour des acteurs ne provoquent pas de déplacement des lignes. Il s'agit simplement d'un parcours de tous les acteurs du jeu afin d'actiter leur fonction interne \textit{update}. Cette mise à jour concerne principalement le poulet dont les déplacements doivent suivre les commandes du joueur. Le fréquence de la mise à jour influe directement sur la réactivité du jeu et donc sur la précision des mouvements. Elle concerne également le déplacement des boules de feu qui évoluent dans le terrain plus rapidement que le défilement général.\\
La gestion des collisions contient 2 parties distinctes :
\begin{enumerate}
\item Collisions avec le poulet : elles sont vérifiées par la fonction \textit{checkCollision} qui, en cas de collision avec un acteur, provoque la mort du poulet, comme dit précédemment.
  \item Collisions entre une boule de feu et un acteur : lors d'une collision entre une boule de feu et un acteur, le monde actuel est réactualisé pour prendre en compte cette collision. De la même manière que pour le défilement de terrain, le nouveau monde est enfilé dans la file des mondes pour mettre à jour les données. Dans ce nouveau monde, on élimine le boule de feu concernée
  \end{enumerate}

\section{Implémentation technique}

Au niveau de l'organisation du projet, nous avons opté pour une structure claire et modulaire. Le répertoire principal contient les fichiers de configuration nécéssaires afin d'utiliser \texttt{ESLint, Jest} et un \texttt{Makefile} qui est destiné à faciliter les différentes tâches de compilation, d'execution et de tests en les automatisants à travers des commandes.

\subsection*{Organisation des fichiers}

\begin{itemize}
  \item \textbf{src/} : contient les fichiers source principaux :
  \begin{itemize}
    \item \texttt{actor.ts} : implémente les fonctions de création et de gestion des acteurs ;
    \item \texttt{world.ts} : contient la logique de simulation du monde, les ticks, le moteur du jeu et l’affichage terminal.
  \end{itemize}
  \item \textbf{test/} : contient les tests unitaires, notamment \texttt{actor.test.ts} qui vérifie le bon fonctionnement des fonctions définies dans \texttt{actor.ts}.
  \item \textbf{dist/} : contient les fichiers JavaScript générés automatiquement à la compilation.
\end{itemize}

\subsection*{Technologies et outils utilisés}

Durant notre projet, nous avons pu aborder plus profondément des outils vu en cours comme :
\begin{itemize}
	\item \texttt{TypeScript} : un langage dérivée de \texttt{Javascript} permettant le typage statique des données
	\item \texttt{ESLint} nous a permis d'assurer une qualité de code constante et formaté homogènement
	\item \texttt{Jest} nous a permis d'écrire et d'executer proprement les tests unitaires
	\item \texttt{terminal-kit} nous a permis d'avoir un affichage propre à l'intérieur même du terminal
\end{itemize}
Le fichier principal d’exécution est \texttt{world.ts}, qui gère l’ensemble de la boucle de jeu.

Le jeu est entièrement jouable depuis un terminal, sans interface graphique additionnelle. L’affichage s’adapte dynamiquement à la taille de l’écran du terminal, ce qui permet une bonne ergonomie malgré l’usage de caractères ASCII.

\subsection*{Génération aléatoire des lignes de jeu}

Les lignes du jeu apparaissent à l'aide de la fonction \texttt{tick\_line}, suivant les principes ci-dessus. Elles sont construites aléatoirement à l'aide de motifs d'acteurs. On choisit d'abord aléatoirement le type de ligne. Puis, on choisit, selon une probabilité \texttt{obstacleProbability}, si l'on place un motif d'acteurs. Ces motifs sont composés de 2 à 4 acteurs de même type. Cela permet de modéliser plus fidèlement les obstacles comme des voitures, camions, ou rangées d'arbres. Seuls les acteurs ennemis sont générés par motif ; les autres, comme les bûches ou "rien", permettent de compléter les lignes. Cette génération aléatoire par choix et combinaison rend très peu probable la répétition exacte de deux lignes, excepté lors d'un bug d'affichage ou 2 lignes identique apparaissent successivement toute les \textit{hauteur de l'écran du terminal}. Nous n'avons malheuresement pas été capable de comprendre et corriger ce problème.
  
\vspace{1em}

Afin de modéliser des niveaux de difficulté différents, nous avons joué sur plusieurs paramètres :
\begin{itemize}
  \item[$\bullet$] la probabilité d'apparition des obstacles, rendant le terrain plus dense en acteurs à "esquiver" ;
  \item[$\bullet$] l'espace entre chaque ligne : dans les premiers niveaux, le joueur dispose d'une ligne sur deux "vide", ce qui lui permet d'être à l'abri d'une collision ;
  \item[$\bullet$] enfin, la répartition des probabilités pour les types de lignes change au cours du temps, pour tendre vers de plus en plus de lignes "dynamiques", telles que les routes ou les rivières.
\end{itemize}

\subsection*{Vitesse de déroulement}

La progression du jeu se fait par un défilement automatique des lignes, mais le comportement du joueur influe sur ce défilement de deux manières différentes :
\begin{itemize}
  \item[$\bullet$] si le joueur est à l'aise avec la difficulté actuelle du niveau, il ira plus vite que le défilement. Ainsi, il risque de sortir du jeu. Pour éviter cela, le rythme de défilement suit la cadence du joueur, l'empêchant d'aller plus haut que le milieu de l'écran ;
  \item[$\bullet$] dans le cas contraire, le joueur est sous pression et doit rattraper son retard. Dans ce cas-là, on garde la vitesse de défilement automatique.
\end{itemize}

\vspace{1em}

Cela permet de maintenir une tension permanente sur le joueur.

\vspace{1em}

Nous n'avons pas implémenté de système garantissant qu'un chemin praticable existe toujours. Premièrement, cette garantie n'est pas nécessaire, car le joueur a la capacité de tirer des projectiles permettant de détruire les obstacles. Ainsi, il peut facilement se tirer d'une impasse. Deuxièmement, ces impasses arrivent relativement rarement grâce à la génération aléatoire de lignes.


\section{Affichage et interactions}
\begin{itemize}
  \item Affichage ASCII dans le terminal
  \item Contraintes liées à \texttt{terminal-kit}
  \item Possibilités d'interactions (touches clavier, etc.)
\end{itemize}

\section{Difficultés rencontrées et solutions apportées}

\subsection*{Affichage trop permanent du poulet}

\subsection*{Affichage désynchronisé avec le jeu}

\subsection*{Problème de synchronisation dans la boucle de jeu}

\subsection*{Efficacité des projectiles}


\section{Évaluation}
\begin{itemize}
  \item Fonctionnalité et stabilité
  \item Performances en terminal
  \item Extensibilité du moteur de jeu
\end{itemize}

\section{Conclusion et perspectives}
Résumé des apports du projet, limites actuelles, et pistes d'amélioration (graphismes, IA, multijoueur, temps réel).

\section*{Références}
\begin{itemize}
  \item Documentation de \texttt{terminal-kit}: \url{https://github.com/cronvel/terminal-kit}
  \item Tutoriel sur le modèle des acteurs
  \item Documentation ESLint / Jest / TypeScript
\end{itemize}

\end{document}
